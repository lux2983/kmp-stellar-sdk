/*
 * Copyright 2025 Soneso
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.soneso.stellar.sdk.sep.sep05

/**
 * Constants for BIP-39 mnemonic generation, BIP-32/SLIP-0010 key derivation,
 * and SEP-5 Stellar key derivation.
 *
 * This object contains all numeric constants required for implementing:
 * - **BIP-39**: Mnemonic code for generating deterministic keys
 *   (https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
 * - **BIP-32**: Hierarchical Deterministic Wallets
 *   (https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
 * - **SLIP-0010**: Universal private key derivation from master private key
 *   (https://github.com/satoshilabs/slips/blob/master/slip-0010.md)
 * - **SLIP-0044**: Registered coin types for BIP-0044
 *   (https://github.com/satoshilabs/slips/blob/master/slip-0044.md)
 * - **SEP-5**: Key Derivation Methods for Stellar Keys
 *   (https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0005.md)
 *
 * These constants ensure interoperability with other BIP-39/BIP-32 compliant wallets
 * and are critical for deterministic key generation and recovery.
 */
public object MnemonicConstants {

    // ========== Entropy Sizes (bits) - BIP-39 Word Lengths ==========
    //
    // BIP-39 defines the relationship between entropy and word count:
    // - CS = ENT / 32 (checksum bits)
    // - MS = (ENT + CS) / 11 (mnemonic sentence length in words)
    //
    // Reference: BIP-39, Section "Generating the mnemonic"

    /**
     * Entropy bits for 12-word mnemonics.
     *
     * Calculation: 128 bits entropy + 4 bits checksum = 132 bits / 11 = 12 words.
     * Security: 128 bits (~10^38 combinations) - adequate security for most use cases.
     */
    public const val ENTROPY_BITS_12_WORDS: Int = 128

    /**
     * Entropy bits for 15-word mnemonics.
     *
     * Calculation: 160 bits entropy + 5 bits checksum = 165 bits / 11 = 15 words.
     * Security: 160 bits (~10^48 combinations) - good security.
     */
    public const val ENTROPY_BITS_15_WORDS: Int = 160

    /**
     * Entropy bits for 18-word mnemonics.
     *
     * Calculation: 192 bits entropy + 6 bits checksum = 198 bits / 11 = 18 words.
     * Security: 192 bits (~10^57 combinations) - strong security.
     */
    public const val ENTROPY_BITS_18_WORDS: Int = 192

    /**
     * Entropy bits for 21-word mnemonics.
     *
     * Calculation: 224 bits entropy + 7 bits checksum = 231 bits / 11 = 21 words.
     * Security: 224 bits (~10^67 combinations) - very strong security.
     */
    public const val ENTROPY_BITS_21_WORDS: Int = 224

    /**
     * Entropy bits for 24-word mnemonics.
     *
     * Calculation: 256 bits entropy + 8 bits checksum = 264 bits / 11 = 24 words.
     * Security: 256 bits (~10^77 combinations) - maximum security, recommended for long-term storage.
     */
    public const val ENTROPY_BITS_24_WORDS: Int = 256

    // ========== Entropy Validation (bytes) ==========

    /**
     * Minimum entropy size in bytes (128 bits = 16 bytes).
     *
     * Per BIP-39: "The mnemonic must encode entropy in a multiple of 32 bits.
     * With more entropy security is improved but the sentence length increases.
     * We refer to the initial entropy length as ENT. The allowed size of ENT
     * is 128-256 bits."
     */
    public const val MIN_ENTROPY_BYTES: Int = 16

    /**
     * Maximum entropy size in bytes (256 bits = 32 bytes).
     *
     * Per BIP-39: The maximum allowed entropy is 256 bits, which produces
     * a 24-word mnemonic.
     */
    public const val MAX_ENTROPY_BYTES: Int = 32

    /**
     * Entropy must be a multiple of 4 bytes (32 bits).
     *
     * Per BIP-39: "The mnemonic must encode entropy in a multiple of 32 bits."
     * Valid sizes: 16, 20, 24, 28, or 32 bytes.
     */
    public const val ENTROPY_MULTIPLE_BYTES: Int = 4

    /**
     * Entropy must be a multiple of 32 bits.
     *
     * This is the bit equivalent of [ENTROPY_MULTIPLE_BYTES].
     */
    public const val ENTROPY_MULTIPLE_BITS: Int = 32

    // ========== Checksum Calculation ==========

    /**
     * Number of entropy bits per checksum bit.
     *
     * Per BIP-39: "A checksum is generated by taking the first ENT / 32 bits
     * of its SHA256 hash."
     */
    public const val CHECKSUM_BITS_PER_32_ENT: Int = 32

    /**
     * Ratio used to calculate the divider index between entropy and checksum bits.
     *
     * For a mnemonic of length MS words, the entropy portion is:
     * entropy_bits = (MS * 11) * 32 / 33
     *
     * This comes from: ENT + CS = MS * 11 and CS = ENT / 32
     * Solving: ENT = (MS * 11 * 32) / 33
     */
    public const val MNEMONIC_DIVIDER_RATIO: Int = 33

    /**
     * Number of bits encoded by each word in the mnemonic.
     *
     * Per BIP-39: The word list contains 2048 words (2^11), so each word
     * encodes exactly 11 bits of information.
     */
    public const val BITS_PER_WORD: Int = 11

    /**
     * Size of the BIP-39 word list.
     *
     * Per BIP-39: "The wordlist is created in such a way that it's enough to
     * type the first four characters to unambiguously identify the word."
     * The list contains exactly 2048 words (2^11).
     */
    public const val WORD_LIST_SIZE: Int = 2048

    // ========== PBKDF2 Parameters (BIP-39 Standard) ==========

    /**
     * Block length for SHA-512 in bytes.
     *
     * SHA-512 processes data in 1024-bit (128-byte) blocks.
     * This is used internally by PBKDF2-HMAC-SHA512.
     */
    public const val PBKDF2_BLOCK_LENGTH: Int = 128

    /**
     * Number of PBKDF2 iterations specified by BIP-39.
     *
     * Per BIP-39: "To create a binary seed from the mnemonic, we use the
     * PBKDF2 function with a mnemonic sentence (in UTF-8 NFKD) used as the
     * password and the string 'mnemonic' + passphrase (again in UTF-8 NFKD)
     * used as the salt. The iteration count is set to 2048."
     */
    public const val PBKDF2_ITERATIONS: Int = 2048

    /**
     * Output key length in bytes for PBKDF2 (512 bits = 64 bytes).
     *
     * Per BIP-39: "The length of the derived key is 512 bits (= 64 bytes)."
     */
    public const val PBKDF2_KEY_LENGTH: Int = 64

    /**
     * Salt prefix for PBKDF2 mnemonic-to-seed conversion.
     *
     * Per BIP-39: The salt is composed of the string "mnemonic" concatenated
     * with the optional passphrase. If no passphrase is provided, the salt
     * is simply "mnemonic".
     */
    public const val PBKDF2_SALT_PREFIX: String = "mnemonic"

    // ========== HD Wallet / SLIP-0010 Constants ==========

    /**
     * Size of derived Ed25519 private keys in bytes.
     *
     * Ed25519 private keys (seeds) are 32 bytes (256 bits).
     * The first 32 bytes of HMAC-SHA512 output are used as the key.
     */
    public const val DERIVED_KEY_BYTES: Int = 32

    /**
     * Size of chain code in bytes.
     *
     * Per BIP-32/SLIP-0010: The chain code is 32 bytes (256 bits) and is
     * derived from the last 32 bytes of HMAC-SHA512 output.
     */
    public const val CHAIN_CODE_BYTES: Int = 32

    /**
     * Offset for hardened child key derivation (2^31).
     *
     * Per BIP-32: "Hardened child keys are derived using indices i >= 2^31
     * (i.e., the leftmost bit is set). Normal child keys use indices i < 2^31."
     *
     * SLIP-0010 requires hardened derivation for Ed25519 keys because
     * Ed25519 does not support non-hardened derivation.
     *
     * SEP-5 uses the path m/44'/148'/n' where all components are hardened.
     */
    public const val BIP32_HARDENED_OFFSET: Long = 2147483648L // 2^31

    /**
     * Length of data input for HMAC in child key derivation.
     *
     * Per SLIP-0010: For Ed25519 hardened derivation, the data is:
     * 0x00 (1 byte) || private_key (32 bytes) || index (4 bytes) = 37 bytes
     */
    public const val HD_DERIVATION_DATA_LENGTH: Int = 37 // 1 + 32 + 4

    /**
     * HMAC key for master key generation.
     *
     * Per SLIP-0010: "Generate a seed byte sequence S of 512 bits...
     * Calculate I = HMAC-SHA512(Key = 'ed25519 seed', Data = S).
     * Split I into two 32-byte sequences, IL and IR."
     *
     * IL becomes the master private key, IR becomes the master chain code.
     */
    public const val ED25519_SEED_KEY: String = "ed25519 seed"

    // ========== Stellar-Specific Constants (SLIP-0044) ==========

    /**
     * Stellar's registered coin type in SLIP-0044.
     *
     * Per SLIP-0044: Stellar (XLM) is registered with coin type 148.
     * See: https://github.com/satoshilabs/slips/blob/master/slip-0044.md
     *
     * SEP-5 derivation path: m/44'/148'/n'
     * - 44' = BIP-44 purpose
     * - 148' = Stellar coin type
     * - n' = account index (hardened)
     */
    public const val STELLAR_COIN_TYPE: Int = 148

    /**
     * BIP-44 purpose field.
     *
     * Per BIP-44: "We define the following 5 levels in BIP32 path:
     * m / purpose' / coin_type' / account' / change / address_index
     *
     * Purpose is a constant set to 44' following the BIP43 recommendation."
     *
     * Note: SEP-5 uses a simplified 3-level path (m/44'/148'/n') rather
     * than the full BIP-44 5-level path, as Stellar does not have the
     * concept of change addresses.
     */
    public const val BIP44_PURPOSE: Int = 44

    // ========== Random Byte Generation ==========

    /**
     * Exclusive upper bound for random byte values.
     *
     * Byte values range from 0 to 255 (0x00 to 0xFF).
     * This constant is used when converting random bytes to bit strings.
     */
    public const val RANDOM_BYTE_MAX_VALUE: Int = 256
}
